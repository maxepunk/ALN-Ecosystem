<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="google-cast-sdk" content="enabled">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Case File: About Last Night</title>

    <!-- Google Fonts - Distinctive Typography Stack -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Playfair+Display:wght@600;700;800;900&family=Special+Elite&display=swap" rel="stylesheet">

    <style>
        /* ============================================
           CSS CUSTOM PROPERTIES - "CLASSIFIED EVIDENCE TERMINAL"
           Color palette: surveillance-era investigation aesthetic
           ============================================ */
        :root {
            /* Core Palette */
            --void-black: #0a0908;
            --paper-cream: #f5f0e6;
            --paper-shadow: #d4cfc4;
            --paper-dark: #ebe6dc;
            --evidence-red: #c41e3a;
            --evidence-red-dark: #8b0000;
            --terminal-green: #00ff41;
            --terminal-amber: #ffb000;
            --ink-black: #1a1a1a;
            --redaction-black: #0d0d0d;

            /* Typography */
            --font-display: 'Playfair Display', Georgia, serif;
            --font-typewriter: 'Special Elite', 'Courier New', monospace;
            --font-body: 'Libre Baskerville', Georgia, serif;
            --font-mono: 'IBM Plex Mono', 'Consolas', monospace;

            /* Layout */
            --header-height: 80px;
            --ticker-height: 100px;
            --content-padding: 2rem;
            --card-gap: 1.5rem;

            /* Animation Timings */
            --load-vignette: 0ms;
            --load-scanlines: 200ms;
            --load-header: 400ms;
            --load-hero: 800ms;
            --load-cards: 1200ms;
            --load-ticker: 2000ms;
        }

        /* ============================================
           RESET & BASE STYLES
           ============================================ */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-body);
            background: var(--void-black);
            color: var(--paper-cream);
            position: relative;
        }

        /* ============================================
           ATMOSPHERIC OVERLAYS
           Film grain, vignette, scan lines
           ============================================ */

        /* Film Grain Overlay - SVG noise texture */
        .grain-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9000;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Vignette Effect - surveillance camera aesthetic */
        .vignette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 8999;
            background: radial-gradient(
                ellipse at center,
                transparent 40%,
                rgba(0, 0, 0, 0.3) 70%,
                rgba(0, 0, 0, 0.6) 100%
            );
            opacity: 0;
            animation: fadeIn 1s ease-out forwards;
            animation-delay: var(--load-vignette);
        }

        /* Scan Lines - CRT monitor effect */
        .scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 8998;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.03) 2px,
                rgba(0, 0, 0, 0.03) 4px
            );
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: var(--load-scanlines);
        }

        /* Scan Line Sweep Animation - periodic effect */
        .scanline-overlay::after {
            content: '';
            position: absolute;
            top: -100%;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(
                180deg,
                transparent 0%,
                rgba(255, 255, 255, 0.02) 50%,
                transparent 100%
            );
            animation: scanlineSweep 8s linear infinite;
            animation-delay: 3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scanlineSweep {
            0% { top: -50%; }
            100% { top: 150%; }
        }

        /* ============================================
           MAIN LAYOUT STRUCTURE
           Header | Content (Hero + Feed) | Ticker
           ============================================ */
        .evidence-board {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        /* ============================================
           HEADER - "Case File Header"
           ============================================ */
        .case-header {
            height: var(--header-height);
            background: linear-gradient(180deg, var(--ink-black) 0%, var(--void-black) 100%);
            border-bottom: 2px solid var(--evidence-red);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--content-padding);
            font-family: var(--font-mono);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            position: relative;
            z-index: 100;
            opacity: 0;
            animation: slideDown 0.6s ease-out forwards;
            animation-delay: var(--load-header);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-100%);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .case-title {
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            font-weight: 700;
            color: var(--paper-cream);
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .case-title::before {
            content: '';
            display: inline-block;
            width: 1.5em;
            height: 1.5em;
            background: var(--evidence-red);
            clip-path: polygon(0 0, 100% 0, 100% 70%, 70% 100%, 0 100%);
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 2rem;
            font-size: clamp(0.75rem, 1.5vw, 1rem);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--terminal-green);
            box-shadow: 0 0 10px var(--terminal-green);
            animation: pulse 2s ease-in-out infinite;
        }

        .status-indicator.offline .status-dot {
            background: var(--evidence-red);
            box-shadow: 0 0 10px var(--evidence-red);
            animation: none;
        }

        .status-indicator.connecting .status-dot {
            background: var(--terminal-amber);
            box-shadow: 0 0 10px var(--terminal-amber);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .rec-indicator {
            color: var(--evidence-red);
            font-weight: 700;
            animation: recBlink 1.5s step-end infinite;
        }

        @keyframes recBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .timestamp {
            color: var(--terminal-green);
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.1em;
        }

        .timestamp .colon {
            animation: colonBlink 1s step-end infinite;
        }

        @keyframes colonBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* ============================================
           MAIN CONTENT AREA
           Hero Evidence + Feed Grid
           ============================================ */
        .evidence-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: var(--content-padding);
            padding-bottom: 0;
            overflow: hidden;
            gap: var(--card-gap);
        }

        /* ============================================
           HERO EVIDENCE CARD - "Latest Discovery"
           ============================================ */
        .hero-evidence {
            background:
                url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='paper'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.04' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23paper)' opacity='0.03'/%3E%3C/svg%3E"),
                linear-gradient(to bottom, var(--paper-cream) 0%, var(--paper-dark) 100%);
            border: 1px solid var(--paper-shadow);
            box-shadow:
                4px 4px 0 var(--ink-black),
                0 20px 40px rgba(0, 0, 0, 0.4);
            transform: rotate(-0.3deg);
            position: relative;
            padding: 2rem 2.5rem;
            min-height: 200px;
            opacity: 0;
            animation: evidenceIncoming 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            animation-delay: var(--load-hero);
        }

        @keyframes evidenceIncoming {
            0% {
                opacity: 0;
                transform: translateY(-50px) rotate(-5deg);
            }
            60% {
                transform: translateY(10px) rotate(1deg);
            }
            80% {
                transform: translateY(-5px) rotate(-0.5deg);
            }
            100% {
                opacity: 1;
                transform: translateY(0) rotate(-0.3deg);
            }
        }

        /* Red tape label */
        .hero-evidence::before {
            content: 'LATEST EVIDENCE';
            position: absolute;
            top: -12px;
            left: 30px;
            background: var(--evidence-red);
            color: white;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            font-weight: 700;
            padding: 6px 16px;
            letter-spacing: 0.15em;
            transform: rotate(-2deg);
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Pushpin decoration */
        .hero-evidence::after {
            content: '';
            position: absolute;
            top: -8px;
            right: 40px;
            width: 16px;
            height: 16px;
            background: radial-gradient(circle at 30% 30%, #dc3545 0%, var(--evidence-red-dark) 100%);
            border-radius: 50%;
            box-shadow:
                0 3px 6px rgba(0, 0, 0, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
        }

        .hero-evidence__header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .hero-evidence__team {
            font-family: var(--font-mono);
            font-size: 0.875rem;
            color: var(--evidence-red);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
        }

        .hero-evidence__time {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: rgba(26, 26, 26, 0.6);
        }

        .hero-evidence__summary {
            font-family: var(--font-typewriter);
            font-size: clamp(1.5rem, 3vw, 2.25rem);
            color: var(--ink-black);
            line-height: 1.5;
            overflow: hidden;
        }

        .hero-evidence__summary .typewriter-text {
            display: inline-block;
            overflow: hidden;
            white-space: nowrap;
            animation: typewriter 2s steps(60) forwards;
            animation-delay: calc(var(--load-hero) + 400ms);
            width: 0;
        }

        @keyframes typewriter {
            from { width: 0; }
            to { width: 100%; }
        }

        /* Empty state for hero */
        .hero-evidence.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 180px;
        }

        .hero-evidence.empty .empty-message {
            font-family: var(--font-mono);
            font-size: 1rem;
            color: rgba(26, 26, 26, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        /* ============================================
           EVIDENCE FEED - Accumulated Cards
           ============================================ */
        .evidence-feed {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--card-gap);
            overflow: hidden;
            align-content: start;
        }

        @media (max-width: 1400px) {
            .evidence-feed {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 1000px) {
            .evidence-feed {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .evidence-card {
            background: var(--paper-cream);
            border-left: 4px solid var(--evidence-red);
            padding: 1.25rem;
            position: relative;
            transform: rotate(var(--rotation, 0deg));
            box-shadow:
                2px 2px 0 var(--ink-black),
                0 8px 20px rgba(0, 0, 0, 0.2);
            opacity: 0;
            animation: cardCascade 0.5s ease-out forwards;
        }

        @keyframes cardCascade {
            from {
                opacity: 0;
                transform: translateY(-30px) rotate(var(--rotation, 0deg));
            }
            to {
                opacity: 1;
                transform: translateY(0) rotate(var(--rotation, 0deg));
            }
        }

        /* Pushpin on each card */
        .evidence-card::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 12px;
            background: radial-gradient(circle at 30% 30%, #dc3545 0%, var(--evidence-red-dark) 100%);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .evidence-card__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .evidence-card__team {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--evidence-red);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
        }

        .evidence-card__time {
            font-family: var(--font-mono);
            font-size: 0.625rem;
            color: rgba(26, 26, 26, 0.5);
        }

        .evidence-card__text {
            font-family: var(--font-body);
            font-size: clamp(0.875rem, 1.5vw, 1.1rem);
            color: var(--ink-black);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* New evidence flash effect */
        .evidence-card.new-evidence {
            animation: cardCascade 0.5s ease-out forwards, evidenceFlash 0.3s ease-out;
        }

        @keyframes evidenceFlash {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.8); }
            100% { box-shadow: 2px 2px 0 var(--ink-black), 0 8px 20px rgba(0, 0, 0, 0.2); }
        }

        /* Screen flash for new evidence */
        .flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            pointer-events: none;
            z-index: 9500;
            opacity: 0;
        }

        .flash-overlay.active {
            animation: screenFlash 0.4s ease-out;
        }

        @keyframes screenFlash {
            0% { opacity: 0; }
            10% { opacity: 0.3; }
            100% { opacity: 0; }
        }

        /* Empty feed state */
        .evidence-feed-empty {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            font-family: var(--font-mono);
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        /* ============================================
           SCORE TICKER - "Terminal Readout"
           ============================================ */
        .score-ticker {
            height: var(--ticker-height);
            background: var(--redaction-black);
            border-top: 1px solid var(--terminal-green);
            font-family: var(--font-mono);
            color: var(--terminal-green);
            display: flex;
            align-items: center;
            padding: 0 var(--content-padding);
            gap: 3rem;
            overflow: hidden;
            position: relative;
            z-index: 100;
            opacity: 0;
            animation: tickerSlideUp 0.6s ease-out forwards;
            animation-delay: var(--load-ticker);
        }

        @keyframes tickerSlideUp {
            from {
                opacity: 0;
                transform: translateY(100%);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .score-ticker.hidden {
            display: none;
        }

        .ticker-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: rgba(0, 255, 65, 0.6);
            white-space: nowrap;
        }

        .ticker-entries {
            display: flex;
            flex: 1;
            gap: 3rem;
            overflow: hidden;
        }

        .score-entry {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-shrink: 0;
        }

        .score-entry__rank {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--terminal-amber);
            min-width: 2rem;
        }

        .score-entry__team {
            font-size: 0.875rem;
            color: var(--terminal-green);
            min-width: 80px;
        }

        .score-entry__amount {
            font-size: 1.25rem;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.05em;
            min-width: 100px;
        }

        .score-entry__amount.updating {
            animation: scoreFlash 0.5s ease-out;
        }

        @keyframes scoreFlash {
            0%, 100% { color: var(--terminal-green); }
            50% { color: var(--terminal-amber); }
        }

        .score-entry__bar {
            width: 120px;
            height: 8px;
            background: rgba(0, 255, 65, 0.2);
            position: relative;
            overflow: hidden;
        }

        .score-entry__bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--terminal-green) 0%, var(--terminal-amber) 100%);
            transition: width 0.5s ease-out;
        }

        /* Empty ticker state */
        .ticker-empty {
            font-size: 0.875rem;
            color: rgba(0, 255, 65, 0.4);
            letter-spacing: 0.1em;
        }

        /* ============================================
           DISPLAY MODE OVERLAY
           Shown when VLC is playing video
           ============================================ */
        .display-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .display-mode-overlay.active {
            display: flex;
        }

        .display-mode-overlay-text {
            color: rgba(255, 255, 255, 0.3);
            font-family: var(--font-mono);
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.3em;
        }

        /* ============================================
           KIOSK MODE OVERRIDES
           Activated via ?kiosk=true URL parameter
           ============================================ */
        body.kiosk-mode {
            cursor: none;
        }

        body.kiosk-mode ::-webkit-scrollbar {
            display: none;
        }

        body.kiosk-mode .case-header .status-indicator:first-child {
            display: none;
        }

        /* Detective mode - hide score ticker */
        body.mode-detective .score-ticker {
            display: none;
        }

        body.mode-detective .evidence-content {
            padding-bottom: var(--content-padding);
        }

        /* ============================================
           LOADING STATE
           ============================================ */
        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: var(--font-mono);
            font-size: 1rem;
            color: var(--terminal-green);
            text-transform: uppercase;
            letter-spacing: 0.3em;
            z-index: 200;
        }

        .loading-indicator.hidden {
            display: none;
        }

        .loading-indicator::after {
            content: '';
            animation: loadingDots 1.5s infinite;
        }

        @keyframes loadingDots {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
        }

        /* ============================================
           UTILITY CLASSES
           ============================================ */
        .hidden { display: none !important; }
        .invisible { visibility: hidden; }
    </style>
</head>
<body>
    <!-- Atmospheric Overlays -->
    <div class="grain-overlay"></div>
    <div class="vignette-overlay"></div>
    <div class="scanline-overlay"></div>
    <div class="flash-overlay" id="flashOverlay"></div>

    <!-- Main Evidence Board -->
    <div class="evidence-board">
        <!-- Case File Header -->
        <header class="case-header">
            <div class="case-title">
                <span>CASE FILE: ABOUT LAST NIGHT</span>
            </div>
            <div class="header-status">
                <div class="status-indicator" id="connectionStatus">
                    <span class="status-dot"></span>
                    <span id="statusText">CONNECTING</span>
                </div>
                <span class="rec-indicator">REC</span>
                <span class="timestamp" id="timestamp">
                    <span class="hours">00</span><span class="colon">:</span><span class="minutes">00</span><span class="colon">:</span><span class="seconds">00</span>
                </span>
            </div>
        </header>

        <!-- Evidence Content Area -->
        <main class="evidence-content">
            <!-- Hero Evidence Card -->
            <article class="hero-evidence empty" id="heroEvidence">
                <span class="empty-message">Awaiting evidence...</span>
            </article>

            <!-- Evidence Feed Grid -->
            <div class="evidence-feed" id="evidenceFeed">
                <div class="evidence-feed-empty">
                    Investigation in progress...
                </div>
            </div>
        </main>

        <!-- Score Ticker -->
        <footer class="score-ticker" id="scoreTicker">
            <span class="ticker-label">STANDINGS</span>
            <div class="ticker-entries" id="tickerEntries">
                <span class="ticker-empty">No scores recorded</span>
            </div>
        </footer>
    </div>

    <!-- Display Mode Overlay -->
    <div class="display-mode-overlay" id="displayModeOverlay">
        <span class="display-mode-overlay-text">Video Playing...</span>
    </div>

    <!-- Loading Indicator -->
    <div class="loading-indicator" id="loadingIndicator">
        INITIALIZING
    </div>

    <!-- Socket.io Client Library -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            adminPassword: '@LN-c0nn3ct',
            deviceId: 'SCOREBOARD_DISPLAY',
            apiUrl: window.location.origin,
            reconnectDelay: 2000,
            tokenRefreshInterval: 23 * 60 * 60 * 1000,
            maxFeedCards: 8,
            heroDisplayDuration: 15000, // Time before hero moves to feed
        };

        // ============================================
        // STATE
        // ============================================
        const state = {
            socket: null,
            token: null,
            isConnected: false,
            teamScores: new Map(),
            evidenceLog: [],        // All evidence entries (accumulating)
            heroEvidence: null,     // Current hero card
            heroTimeout: null,      // Timer for hero rotation
            displayMode: 'SCOREBOARD',
            kioskMode: false,
            viewMode: 'blackmarket', // 'blackmarket' or 'detective'
        };

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const elements = {
            connectionStatus: document.getElementById('connectionStatus'),
            statusText: document.getElementById('statusText'),
            heroEvidence: document.getElementById('heroEvidence'),
            evidenceFeed: document.getElementById('evidenceFeed'),
            scoreTicker: document.getElementById('scoreTicker'),
            tickerEntries: document.getElementById('tickerEntries'),
            flashOverlay: document.getElementById('flashOverlay'),
            displayModeOverlay: document.getElementById('displayModeOverlay'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            timestamp: document.getElementById('timestamp'),
        };

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function formatTime(date) {
            return new Date(date).toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
        }

        function getRandomRotation() {
            const rotations = [-1.5, -1, -0.5, 0.5, 1, 1.5];
            return rotations[Math.floor(Math.random() * rotations.length)];
        }

        // ============================================
        // TIMESTAMP CLOCK
        // ============================================
        function updateTimestamp() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');

            elements.timestamp.querySelector('.hours').textContent = hours;
            elements.timestamp.querySelector('.minutes').textContent = minutes;
            elements.timestamp.querySelector('.seconds').textContent = seconds;
        }

        setInterval(updateTimestamp, 1000);
        updateTimestamp();

        // ============================================
        // MODE INITIALIZATION
        // ============================================
        function initModes() {
            const urlParams = new URLSearchParams(window.location.search);

            // Kiosk mode
            state.kioskMode = urlParams.get('kiosk') === 'true';
            if (state.kioskMode) {
                document.body.classList.add('kiosk-mode');
                console.log('[Scoreboard] Kiosk mode enabled');

                document.body.addEventListener('click', () => {
                    if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.warn('[Scoreboard] Fullscreen request denied:', err);
                        });
                    }
                }, { once: true });
            }

            // View mode (detective hides ticker)
            const modeParam = urlParams.get('mode');
            if (modeParam === 'detective') {
                state.viewMode = 'detective';
                document.body.classList.add('mode-detective');
                console.log('[Scoreboard] Detective mode - ticker hidden');
            }
        }

        // ============================================
        // DISPLAY MODE HANDLING
        // ============================================
        function handleDisplayMode(data) {
            const { mode } = data;
            state.displayMode = mode;
            const overlay = elements.displayModeOverlay;

            console.log('[Scoreboard] Display mode changed:', mode);

            switch (mode) {
                case 'IDLE_LOOP':
                case 'VIDEO':
                    if (state.kioskMode) {
                        overlay.classList.add('active');
                    }
                    break;
                case 'SCOREBOARD':
                    overlay.classList.remove('active');
                    break;
            }
        }

        // ============================================
        // CONNECTION STATUS
        // ============================================
        function updateConnectionStatus(status, text) {
            elements.connectionStatus.className = `status-indicator ${status}`;
            elements.statusText.textContent = text.toUpperCase();
        }

        // ============================================
        // EVIDENCE RENDERING
        // ============================================
        function triggerFlash() {
            elements.flashOverlay.classList.add('active');
            setTimeout(() => {
                elements.flashOverlay.classList.remove('active');
            }, 400);
        }

        function renderHeroEvidence() {
            const hero = elements.heroEvidence;

            if (!state.heroEvidence) {
                hero.classList.add('empty');
                hero.innerHTML = '<span class="empty-message">Awaiting evidence...</span>';
                return;
            }

            const evidence = state.heroEvidence;
            hero.classList.remove('empty');
            hero.innerHTML = `
                <div class="hero-evidence__header">
                    <span class="hero-evidence__team">TEAM ${escapeHtml(evidence.teamId)}</span>
                    <span class="hero-evidence__time">${formatTime(evidence.timestamp)}</span>
                </div>
                <div class="hero-evidence__summary">
                    ${escapeHtml(evidence.summary || evidence.tokenId)}
                </div>
            `;

            // Reset animation
            hero.style.animation = 'none';
            hero.offsetHeight; // Trigger reflow
            hero.style.animation = '';
        }

        function renderEvidenceFeed() {
            const feed = elements.evidenceFeed;

            // Get evidence excluding current hero
            const feedEvidence = state.evidenceLog
                .filter(e => !state.heroEvidence || e.id !== state.heroEvidence.id)
                .slice(0, CONFIG.maxFeedCards);

            if (feedEvidence.length === 0) {
                feed.innerHTML = '<div class="evidence-feed-empty">Investigation in progress...</div>';
                return;
            }

            const cardsHtml = feedEvidence.map((evidence, index) => {
                const rotation = getRandomRotation();
                const delay = index * 100;

                return `
                    <article class="evidence-card"
                             style="--rotation: ${rotation}deg; animation-delay: ${delay}ms;"
                             data-id="${evidence.id}">
                        <div class="evidence-card__header">
                            <span class="evidence-card__team">TEAM ${escapeHtml(evidence.teamId)}</span>
                            <span class="evidence-card__time">${formatTime(evidence.timestamp)}</span>
                        </div>
                        <div class="evidence-card__text">
                            ${escapeHtml(evidence.summary || evidence.tokenId)}
                        </div>
                    </article>
                `;
            }).join('');

            feed.innerHTML = cardsHtml;
        }

        function addEvidence(transaction) {
            // Create evidence entry
            const evidence = {
                id: transaction.id || `${transaction.tokenId}-${transaction.teamId}-${Date.now()}`,
                tokenId: transaction.tokenId,
                teamId: transaction.teamId,
                timestamp: transaction.timestamp || new Date().toISOString(),
                summary: transaction.summary || null,
            };

            // Check for duplicates
            if (state.evidenceLog.some(e => e.id === evidence.id)) {
                return;
            }

            // Flash effect for new evidence
            triggerFlash();

            // Move current hero to feed if exists
            if (state.heroEvidence) {
                // Add old hero to front of feed
                state.evidenceLog.unshift(state.heroEvidence);
            }

            // Set new evidence as hero
            state.heroEvidence = evidence;

            // Render updates
            renderHeroEvidence();
            renderEvidenceFeed();

            // Trim evidence log to prevent memory issues
            if (state.evidenceLog.length > 100) {
                state.evidenceLog = state.evidenceLog.slice(0, 100);
            }

            console.log('[Scoreboard] Evidence added:', evidence.tokenId, 'for team', evidence.teamId);
        }

        // ============================================
        // SCORE RENDERING
        // ============================================
        function renderScoreboard() {
            const scores = Array.from(state.teamScores.values())
                .filter(team => team.tokensScanned > 0)
                .sort((a, b) => b.currentScore - a.currentScore);

            if (scores.length === 0) {
                elements.tickerEntries.innerHTML = '<span class="ticker-empty">No scores recorded</span>';
                return;
            }

            const maxScore = scores[0]?.currentScore || 1;

            const entriesHtml = scores.slice(0, 6).map((team, index) => {
                const rank = index + 1;
                const barWidth = (team.currentScore / maxScore) * 100;

                return `
                    <div class="score-entry" data-team="${team.teamId}">
                        <span class="score-entry__rank">${rank}</span>
                        <span class="score-entry__team">TEAM ${escapeHtml(team.teamId)}</span>
                        <span class="score-entry__amount">$${team.currentScore.toLocaleString()}</span>
                        <div class="score-entry__bar">
                            <div class="score-entry__bar-fill" style="width: ${barWidth}%"></div>
                        </div>
                    </div>
                `;
            }).join('');

            elements.tickerEntries.innerHTML = entriesHtml;
        }

        function updateTeamScore(scoreData) {
            const existingScore = state.teamScores.get(scoreData.teamId);
            state.teamScores.set(scoreData.teamId, scoreData);

            // Animate score change
            if (existingScore && existingScore.currentScore !== scoreData.currentScore) {
                setTimeout(() => {
                    const entry = document.querySelector(`.score-entry[data-team="${scoreData.teamId}"] .score-entry__amount`);
                    if (entry) {
                        entry.classList.add('updating');
                        setTimeout(() => entry.classList.remove('updating'), 500);
                    }
                }, 100);
            }

            renderScoreboard();
        }

        // ============================================
        // AUTHENTICATION
        // ============================================
        async function authenticate() {
            try {
                const response = await fetch(`${CONFIG.apiUrl}/api/admin/auth`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: CONFIG.adminPassword }),
                });

                if (!response.ok) {
                    throw new Error('Authentication failed');
                }

                const data = await response.json();
                state.token = data.token;

                console.log('[Scoreboard] Authentication successful');
                return true;
            } catch (error) {
                console.error('[Scoreboard] Authentication failed:', error);
                updateConnectionStatus('offline', 'AUTH FAILED');
                setTimeout(authenticate, CONFIG.reconnectDelay);
                return false;
            }
        }

        // ============================================
        // WEBSOCKET CONNECTION
        // ============================================
        function cleanupSocket() {
            if (state.socket) {
                console.log('[Scoreboard] Cleaning up socket');
                state.socket.removeAllListeners();
                if (state.socket.connected) {
                    state.socket.disconnect();
                }
                state.socket = null;
            }
            state.isConnected = false;
        }

        async function connectWebSocket() {
            if (!state.token) {
                console.error('[Scoreboard] No token available');
                return;
            }

            cleanupSocket();
            updateConnectionStatus('connecting', 'CONNECTING');

            try {
                state.socket = io(CONFIG.apiUrl, {
                    transports: ['websocket'],
                    auth: {
                        token: state.token,
                        deviceId: CONFIG.deviceId,
                        deviceType: 'gm',
                        version: '1.0.0',
                    },
                });

                setupSocketHandlers();
            } catch (error) {
                console.error('[Scoreboard] WebSocket connection failed:', error);
                updateConnectionStatus('offline', 'CONN FAILED');
                setTimeout(connectWebSocket, CONFIG.reconnectDelay);
            }
        }

        function setupSocketHandlers() {
            let lastActivityTime = Date.now();
            let zombieCheckInterval = null;

            state.socket.onAny(() => {
                lastActivityTime = Date.now();
            });

            state.socket.on('connect', () => {
                console.log('[Scoreboard] WebSocket connected');
                state.isConnected = true;
                updateConnectionStatus('connected', 'LIVE');
                elements.loadingIndicator.classList.add('hidden');

                state.socket.emit('sync:request');

                if (zombieCheckInterval) clearInterval(zombieCheckInterval);
                zombieCheckInterval = setInterval(() => {
                    const timeSinceActivity = Date.now() - lastActivityTime;
                    if (timeSinceActivity > 5 * 60 * 1000 && state.isConnected) {
                        console.warn('[Scoreboard] Zombie connection detected, reconnecting...');
                        clearInterval(zombieCheckInterval);
                        zombieCheckInterval = null;
                        cleanupSocket();
                        authenticate().then(authenticated => {
                            if (authenticated) connectWebSocket();
                        });
                    }
                }, 60 * 1000);
            });

            state.socket.on('disconnect', (reason) => {
                console.log('[Scoreboard] WebSocket disconnected:', reason);
                state.isConnected = false;
                updateConnectionStatus('offline', 'OFFLINE');

                if (zombieCheckInterval) {
                    clearInterval(zombieCheckInterval);
                    zombieCheckInterval = null;
                }
            });

            state.socket.on('connect_error', (error) => {
                console.error('[Scoreboard] Connection error:', error);
                updateConnectionStatus('offline', 'CONN ERROR');
            });

            state.socket.on('reconnect', () => {
                console.log('[Scoreboard] WebSocket reconnected');
                state.socket.emit('sync:request');
            });

            // Score updates
            state.socket.on('score:updated', (eventData) => {
                const scoreData = eventData.data;
                console.log('[Scoreboard] Score updated:', scoreData);
                updateTeamScore(scoreData);
            });

            // Group completions
            state.socket.on('group:completed', (eventData) => {
                const data = eventData.data;
                console.log('[Scoreboard] Group completed:', data);
                // Could add special visual effect here
            });

            // Transaction events (for evidence log)
            state.socket.on('transaction:new', (eventData) => {
                const transaction = eventData.data?.transaction;
                if (transaction) {
                    console.log('[Scoreboard] New transaction:', transaction);
                    addEvidence(transaction);
                }
            });

            // Full sync
            state.socket.on('sync:full', (eventData) => {
                const data = eventData.data;
                console.log('[Scoreboard] Full sync received:', data);

                // Update scores
                if (data.scores && Array.isArray(data.scores)) {
                    data.scores.forEach(updateTeamScore);
                }
                renderScoreboard();

                // Load recent transactions for evidence log
                if (data.recentTransactions && Array.isArray(data.recentTransactions)) {
                    // Sort by timestamp descending
                    const sorted = [...data.recentTransactions].sort((a, b) =>
                        new Date(b.timestamp) - new Date(a.timestamp)
                    );

                    // Set most recent as hero
                    if (sorted.length > 0) {
                        state.heroEvidence = {
                            id: sorted[0].id || `${sorted[0].tokenId}-${sorted[0].teamId}`,
                            tokenId: sorted[0].tokenId,
                            teamId: sorted[0].teamId,
                            timestamp: sorted[0].timestamp,
                            summary: sorted[0].summary || null,
                        };
                    }

                    // Add rest to feed
                    sorted.slice(1).forEach(tx => {
                        const evidence = {
                            id: tx.id || `${tx.tokenId}-${tx.teamId}`,
                            tokenId: tx.tokenId,
                            teamId: tx.teamId,
                            timestamp: tx.timestamp,
                            summary: tx.summary || null,
                        };
                        if (!state.evidenceLog.some(e => e.id === evidence.id)) {
                            state.evidenceLog.push(evidence);
                        }
                    });

                    renderHeroEvidence();
                    renderEvidenceFeed();
                }
            });

            // Display mode changes
            state.socket.on('display:mode', (eventData) => {
                const data = eventData.data;
                console.log('[Scoreboard] Display mode event:', data);
                handleDisplayMode(data);
            });
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        async function initialize() {
            console.log('[Scoreboard] Initializing Evidence Board...');

            initModes();

            const authenticated = await authenticate();
            if (!authenticated) {
                return;
            }

            await connectWebSocket();

            // Token refresh cycle
            setInterval(async () => {
                console.log('[Scoreboard] Refreshing token...');
                await authenticate();
                if (state.socket && state.socket.connected) {
                    state.socket.disconnect();
                    await connectWebSocket();
                }
            }, CONFIG.tokenRefreshInterval);
        }

        // Start
        initialize();
    </script>
</body>
</html>
